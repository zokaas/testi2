"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodes = exports.createNodesV2 = exports.PLUGIN_NAME = exports.createDependencies = void 0;
const devkit_1 = require("@nx/devkit");
const calculate_hash_for_create_nodes_1 = require("@nx/devkit/src/utils/calculate-hash-for-create-nodes");
const get_named_inputs_1 = require("@nx/devkit/src/utils/get-named-inputs");
const minimatch_1 = require("minimatch");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const file_hasher_1 = require("nx/src/hasher/file-hasher");
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
const lock_file_1 = require("nx/src/plugins/js/lock-file/lock-file");
const cache_directory_1 = require("nx/src/utils/cache-directory");
const ts_config_1 = require("../../utils/typescript/ts-config");
const pmc = (0, devkit_1.getPackageManagerCommand)();
function readTargetsCache(cachePath) {
    return process.env.NX_CACHE_PROJECT_GRAPH !== 'false' && (0, node_fs_1.existsSync)(cachePath)
        ? (0, devkit_1.readJsonFile)(cachePath)
        : {};
}
function writeTargetsToCache(cachePath, results) {
    (0, devkit_1.writeJsonFile)(cachePath, results);
}
/**
 * @deprecated The 'createDependencies' function is now a no-op. This functionality is included in 'createNodesV2'.
 */
const createDependencies = () => {
    return [];
};
exports.createDependencies = createDependencies;
exports.PLUGIN_NAME = '@nx/js/typescript';
const tsConfigGlob = '**/tsconfig*.json';
exports.createNodesV2 = [
    tsConfigGlob,
    async (configFilePaths, options, context) => {
        const optionsHash = (0, file_hasher_1.hashObject)(options);
        const cachePath = (0, node_path_1.join)(cache_directory_1.workspaceDataDirectory, `tsc-${optionsHash}.hash`);
        const targetsCache = readTargetsCache(cachePath);
        const normalizedOptions = normalizePluginOptions(options);
        try {
            return await (0, devkit_1.createNodesFromFiles)((configFile, options, context) => createNodesInternal(configFile, options, context, targetsCache), configFilePaths, normalizedOptions, context);
        }
        finally {
            writeTargetsToCache(cachePath, targetsCache);
        }
    },
];
exports.createNodes = [
    tsConfigGlob,
    async (configFilePath, options, context) => {
        devkit_1.logger.warn('`createNodes` is deprecated. Update your plugin to utilize createNodesV2 instead. In Nx 20, this will change to the createNodesV2 API.');
        const normalizedOptions = normalizePluginOptions(options);
        return createNodesInternal(configFilePath, normalizedOptions, context, {});
    },
];
async function createNodesInternal(configFilePath, options, context, targetsCache) {
    const projectRoot = (0, node_path_1.dirname)(configFilePath);
    const fullConfigPath = (0, devkit_1.joinPathFragments)(context.workspaceRoot, configFilePath);
    // Do not create a project for the workspace root tsconfig files.
    if (projectRoot === '.') {
        return {};
    }
    // Do not create a project if package.json and project.json isn't there.
    const siblingFiles = (0, node_fs_1.readdirSync)((0, node_path_1.join)(context.workspaceRoot, projectRoot));
    if (!siblingFiles.includes('package.json') &&
        !siblingFiles.includes('project.json')) {
        return {};
    }
    // Do not create a project if it's not a tsconfig.json and there is no tsconfig.json in the same directory
    if ((0, node_path_1.basename)(configFilePath) !== 'tsconfig.json' &&
        !siblingFiles.includes('tsconfig.json')) {
        return {};
    }
    const nodeHash = await (0, calculate_hash_for_create_nodes_1.calculateHashForCreateNodes)(projectRoot, options, context, [(0, lock_file_1.getLockFileName)((0, devkit_1.detectPackageManager)(context.workspaceRoot))]);
    // The hash is calculated at the node/project level, so we add the config file path to avoid conflicts when caching
    const cacheKey = `${nodeHash}_${configFilePath}`;
    targetsCache[cacheKey] ??= buildTscTargets(fullConfigPath, projectRoot, options, context);
    const { targets } = targetsCache[cacheKey];
    return {
        projects: {
            [projectRoot]: {
                projectType: 'library',
                targets,
            },
        },
    };
}
function buildTscTargets(configFilePath, projectRoot, options, context) {
    const targets = {};
    const namedInputs = (0, get_named_inputs_1.getNamedInputs)(projectRoot, context);
    const tsConfig = readCachedTsConfig(configFilePath);
    // TODO: check whether we want to always run with --pretty --verbose, it makes replacing scripts harder
    // `--verbose` conflicts with `tsc -b --clean`, might be another reason for not using it, it would
    // prevent users from running the task with `--clean` flag.
    // Should we consider creating a different optional target for `--clean`?
    // Should we consider having a plugin option to disable `--pretty` and `--verbose`?
    let internalProjectReferences;
    // Typecheck target
    if ((0, node_path_1.basename)(configFilePath) === 'tsconfig.json' && options.typecheck) {
        internalProjectReferences = resolveInternalProjectReferences(tsConfig, context.workspaceRoot, projectRoot);
        const targetName = options.typecheck.targetName;
        if (!targets[targetName]) {
            let command = `tsc --build --emitDeclarationOnly --pretty --verbose`;
            if (tsConfig.options.noEmit ||
                Object.values(internalProjectReferences).some((ref) => ref.options.noEmit)) {
                // `--emitDeclarationOnly` and `--noEmit` are mutually exclusive, so
                // we remove `--emitDeclarationOnly` if `--noEmit` is set.
                command = `tsc --build --pretty --verbose`;
            }
            targets[targetName] = {
                dependsOn: [`^${targetName}`],
                command,
                options: { cwd: projectRoot },
                cache: true,
                inputs: getInputs(namedInputs, configFilePath, tsConfig, internalProjectReferences, context.workspaceRoot, projectRoot),
                outputs: getOutputs(configFilePath, tsConfig, internalProjectReferences, context.workspaceRoot, projectRoot),
                syncGenerators: ['@nx/js:typescript-sync'],
                metadata: {
                    technologies: ['typescript'],
                    description: 'Runs type-checking for the project.',
                    help: {
                        command: `${pmc.exec} tsc --build --help`,
                        example: {
                            args: ['--force'],
                        },
                    },
                },
            };
        }
    }
    // Build target
    if (options.build && (0, node_path_1.basename)(configFilePath) === options.build.configName) {
        internalProjectReferences ??= resolveInternalProjectReferences(tsConfig, context.workspaceRoot, projectRoot);
        const targetName = options.build.targetName;
        targets[targetName] = {
            dependsOn: [`^${targetName}`],
            command: `tsc --build ${options.build.configName} --pretty --verbose`,
            options: { cwd: projectRoot },
            cache: true,
            inputs: getInputs(namedInputs, configFilePath, tsConfig, internalProjectReferences, context.workspaceRoot, projectRoot),
            outputs: getOutputs(configFilePath, tsConfig, internalProjectReferences, context.workspaceRoot, projectRoot),
            syncGenerators: ['@nx/js:typescript-sync'],
            metadata: {
                technologies: ['typescript'],
                description: 'Builds the project with `tsc`.',
                help: {
                    command: `${pmc.exec} tsc --build --help`,
                    example: {
                        args: ['--force'],
                    },
                },
            },
        };
    }
    return { targets };
}
function getInputs(namedInputs, configFilePath, tsConfig, internalProjectReferences, workspaceRoot, projectRoot) {
    const configFiles = new Set();
    const includePaths = new Set();
    const excludePaths = new Set();
    const extendedConfigFiles = getExtendedConfigFiles(configFilePath, tsConfig);
    extendedConfigFiles.forEach((configPath) => {
        configFiles.add(configPath);
    });
    const projectTsConfigFiles = [
        [configFilePath, tsConfig],
        ...Object.entries(internalProjectReferences),
    ];
    const absoluteProjectRoot = (0, node_path_1.join)(workspaceRoot, projectRoot);
    projectTsConfigFiles.forEach(([configPath, config]) => {
        configFiles.add(configPath);
        const offset = (0, node_path_1.relative)(absoluteProjectRoot, (0, node_path_1.dirname)(configPath));
        (config.raw?.include ?? []).forEach((p) => includePaths.add((0, node_path_1.join)(offset, p)));
        if (config.raw?.exclude) {
            /**
             * We need to filter out the exclude paths that are already included in
             * other tsconfig files. If they are not included in other tsconfig files,
             * they still correctly apply to the current file and we should keep them.
             */
            const otherFilesInclude = [];
            projectTsConfigFiles.forEach(([path, c]) => {
                if (path !== configPath) {
                    otherFilesInclude.push(...(c.raw?.include ?? []));
                }
            });
            const normalize = (p) => (p.startsWith('./') ? p.slice(2) : p);
            config.raw.exclude.forEach((excludePath) => {
                if (!otherFilesInclude.some((includePath) => (0, minimatch_1.minimatch)(normalize(includePath), normalize(excludePath)) ||
                    (0, minimatch_1.minimatch)(normalize(excludePath), normalize(includePath)))) {
                    excludePaths.add(excludePath);
                }
            });
        }
    });
    const inputs = [];
    if (includePaths.size) {
        inputs.push(...Array.from(configFiles).map((p) => pathToInputOrOutput(p, workspaceRoot, projectRoot)), ...Array.from(includePaths).map((p) => pathToInputOrOutput((0, devkit_1.joinPathFragments)(projectRoot, p), workspaceRoot, projectRoot)));
    }
    else {
        // If we couldn't identify any include paths, we default to the default
        // named inputs.
        inputs.push('production' in namedInputs ? 'production' : 'default');
    }
    if (excludePaths.size) {
        inputs.push(...Array.from(excludePaths).map((p) => `!${pathToInputOrOutput((0, devkit_1.joinPathFragments)(projectRoot, p), workspaceRoot, projectRoot)}`));
    }
    if (hasExternalProjectReferences(configFilePath, tsConfig, workspaceRoot, projectRoot)) {
        // Importing modules from a referenced project will load its output declaration files (d.ts)
        // https://www.typescriptlang.org/docs/handbook/project-references.html#what-is-a-project-reference
        inputs.push({ dependentTasksOutputFiles: '**/*.d.ts' });
    }
    else {
        inputs.push('production' in namedInputs ? '^production' : '^default');
    }
    inputs.push({ externalDependencies: ['typescript'] });
    return inputs;
}
function getOutputs(configFilePath, tsConfig, internalProjectReferences, workspaceRoot, projectRoot) {
    const outputs = new Set();
    // We could have more surgical outputs based on the tsconfig options, but the
    // user could override them through the command line and that wouldn't be
    // reflected in the outputs. So, we just include everything that could be
    // produced by the tsc command.
    [tsConfig, ...Object.values(internalProjectReferences)].forEach((config) => {
        if (config.options.outFile) {
            const outFileName = (0, node_path_1.basename)(config.options.outFile, '.js');
            const outFileDir = (0, node_path_1.dirname)(config.options.outFile);
            outputs.add((0, devkit_1.joinPathFragments)('{workspaceRoot}', (0, node_path_1.relative)(workspaceRoot, config.options.outFile)));
            // outFile is not be used with .cjs, .mjs, .jsx, so the list is simpler
            const outDir = (0, node_path_1.relative)(workspaceRoot, outFileDir);
            outputs.add((0, devkit_1.joinPathFragments)('{workspaceRoot}', outDir, `${outFileName}.js.map`));
            outputs.add((0, devkit_1.joinPathFragments)('{workspaceRoot}', outDir, `${outFileName}.d.ts`));
            outputs.add((0, devkit_1.joinPathFragments)('{workspaceRoot}', outDir, `${outFileName}.d.ts.map`));
            // https://www.typescriptlang.org/tsconfig#tsBuildInfoFile
            outputs.add(tsConfig.options.tsBuildInfoFile
                ? pathToInputOrOutput(tsConfig.options.tsBuildInfoFile, workspaceRoot, projectRoot)
                : (0, devkit_1.joinPathFragments)('{workspaceRoot}', outDir, `${outFileName}.tsbuildinfo`));
        }
        else if (config.options.outDir) {
            outputs.add((0, devkit_1.joinPathFragments)('{workspaceRoot}', (0, node_path_1.relative)(workspaceRoot, config.options.outDir)));
        }
        else if (config.fileNames.length) {
            // tsc produce files in place when no outDir or outFile is set
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.js'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.cjs'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.mjs'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.jsx'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.js.map')); // should also include .cjs and .mjs data
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.jsx.map'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.ts'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.cts'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.mts'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.ts.map'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.cts.map'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.mts.map'));
            // https://www.typescriptlang.org/tsconfig#tsBuildInfoFile
            const name = (0, node_path_1.basename)(configFilePath, '.json');
            outputs.add(tsConfig.options.tsBuildInfoFile
                ? pathToInputOrOutput(tsConfig.options.tsBuildInfoFile, workspaceRoot, projectRoot)
                : (0, devkit_1.joinPathFragments)('{projectRoot}', `${name}.tsbuildinfo`));
        }
    });
    return Array.from(outputs);
}
function pathToInputOrOutput(path, workspaceRoot, projectRoot) {
    const pathRelativeToProjectRoot = (0, devkit_1.normalizePath)((0, node_path_1.relative)(projectRoot, path));
    if (pathRelativeToProjectRoot.startsWith('..')) {
        return (0, devkit_1.joinPathFragments)('{workspaceRoot}', (0, node_path_1.relative)(workspaceRoot, path));
    }
    return (0, devkit_1.joinPathFragments)('{projectRoot}', pathRelativeToProjectRoot);
}
function getExtendedConfigFiles(tsConfigPath, tsConfig) {
    const extendedConfigFiles = new Set();
    let currentConfigPath = tsConfigPath;
    let currentConfig = tsConfig;
    while (currentConfig.raw?.extends) {
        const extendedConfigPath = (0, node_path_1.join)((0, node_path_1.dirname)(currentConfigPath), currentConfig.raw.extends);
        extendedConfigFiles.add(extendedConfigPath);
        const extendedConfig = readCachedTsConfig(extendedConfigPath);
        currentConfigPath = extendedConfigPath;
        currentConfig = extendedConfig;
    }
    return Array.from(extendedConfigFiles);
}
function resolveInternalProjectReferences(tsConfig, workspaceRoot, projectRoot, projectReferences = {}) {
    if (!tsConfig.projectReferences?.length) {
        return projectReferences;
    }
    for (const ref of tsConfig.projectReferences) {
        let refConfigPath = ref.path;
        if (projectReferences[refConfigPath]) {
            // Already resolved
            continue;
        }
        if (!(0, node_fs_1.existsSync)(refConfigPath)) {
            // the referenced tsconfig doesn't exist, ignore it
            continue;
        }
        if (isExternalProjectReference(refConfigPath, workspaceRoot, projectRoot)) {
            continue;
        }
        if (!refConfigPath.endsWith('.json')) {
            refConfigPath = (0, node_path_1.join)(refConfigPath, 'tsconfig.json');
        }
        const refTsConfig = readCachedTsConfig(refConfigPath);
        projectReferences[refConfigPath] = refTsConfig;
        resolveInternalProjectReferences(refTsConfig, workspaceRoot, projectRoot, projectReferences);
    }
    return projectReferences;
}
function hasExternalProjectReferences(tsConfigPath, tsConfig, workspaceRoot, projectRoot, seen = new Set()) {
    if (!tsConfig.projectReferences?.length) {
        return false;
    }
    seen.add(tsConfigPath);
    for (const ref of tsConfig.projectReferences) {
        let refConfigPath = ref.path;
        if (seen.has(refConfigPath)) {
            // Already seen
            continue;
        }
        if (!(0, node_fs_1.existsSync)(refConfigPath)) {
            // the referenced tsconfig doesn't exist, ignore it
            continue;
        }
        if (isExternalProjectReference(refConfigPath, workspaceRoot, projectRoot)) {
            return true;
        }
        if (!refConfigPath.endsWith('.json')) {
            refConfigPath = (0, node_path_1.join)(refConfigPath, 'tsconfig.json');
        }
        const refTsConfig = readCachedTsConfig(refConfigPath);
        const result = hasExternalProjectReferences(refConfigPath, refTsConfig, workspaceRoot, projectRoot, seen);
        if (result) {
            return true;
        }
    }
    return false;
}
function isExternalProjectReference(refTsConfigPath, workspaceRoot, projectRoot) {
    const absoluteProjectRoot = (0, node_path_1.join)(workspaceRoot, projectRoot);
    let currentPath = getTsConfigDirName(refTsConfigPath);
    if ((0, node_path_1.relative)(absoluteProjectRoot, currentPath).startsWith('..')) {
        // it's outside of the project root, so it's an external project reference
        return true;
    }
    while (currentPath !== absoluteProjectRoot) {
        if ((0, node_fs_1.existsSync)((0, node_path_1.join)(currentPath, 'package.json')) ||
            (0, node_fs_1.existsSync)((0, node_path_1.join)(currentPath, 'project.json'))) {
            // it's inside a nested project root, so it's and external project reference
            return true;
        }
        currentPath = (0, node_path_1.dirname)(currentPath);
    }
    // it's inside the project root, so it's an internal project reference
    return false;
}
function getTsConfigDirName(tsConfigPath) {
    return (0, node_fs_1.statSync)(tsConfigPath).isFile()
        ? (0, node_path_1.dirname)(tsConfigPath)
        : (0, node_path_1.normalize)(tsConfigPath);
}
const tsConfigCache = new Map();
function readCachedTsConfig(tsConfigPath) {
    const cacheKey = getTsConfigCacheKey(tsConfigPath);
    if (tsConfigCache.has(cacheKey)) {
        return tsConfigCache.get(cacheKey);
    }
    const tsConfig = (0, ts_config_1.readTsConfig)(tsConfigPath);
    tsConfigCache.set(cacheKey, tsConfig);
    return tsConfig;
}
function getTsConfigCacheKey(tsConfigPath) {
    const timestamp = (0, node_fs_1.statSync)(tsConfigPath).mtimeMs;
    return `${tsConfigPath}-${timestamp}`;
}
function normalizePluginOptions(pluginOptions = {}) {
    const defaultTypecheckTargetName = 'typecheck';
    let typecheck = {
        targetName: defaultTypecheckTargetName,
    };
    if (pluginOptions.typecheck === false) {
        typecheck = false;
    }
    else if (pluginOptions.typecheck &&
        typeof pluginOptions.typecheck !== 'boolean') {
        typecheck = {
            targetName: pluginOptions.typecheck.targetName ?? defaultTypecheckTargetName,
        };
    }
    const defaultBuildTargetName = 'build';
    const defaultBuildConfigName = 'tsconfig.lib.json';
    let build = {
        targetName: defaultBuildTargetName,
        configName: defaultBuildConfigName,
    };
    // Build target is not enabled by default
    if (!pluginOptions.build) {
        build = false;
    }
    else if (pluginOptions.build && typeof pluginOptions.build !== 'boolean') {
        build = {
            targetName: pluginOptions.build.targetName ?? defaultBuildTargetName,
            configName: pluginOptions.build.configName ?? defaultBuildConfigName,
        };
    }
    return {
        typecheck,
        build,
    };
}
