"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findBuildConfig = findBuildConfig;
const devkit_1 = require("@nx/devkit");
const configuration_1 = require("nx/src/config/configuration");
const project_graph_1 = require("nx/src/project-graph/project-graph");
async function findBuildConfig(tree, options) {
    try {
        // attempt to use the provided target
        const graph = await (0, devkit_1.createProjectGraphAsync)();
        if (options.buildTarget) {
            return {
                target: options.buildTarget,
                config: findInTarget(tree, graph, options),
            };
        }
        // check to see if there is a valid config in the given project
        const selfProject = findTargetOptionsInProject(tree, graph, options.project, options);
        if (selfProject) {
            return selfProject;
        }
        // attempt to find any projects with the valid config in the graph that consumes this project
        return await findInGraph(tree, graph, options);
    }
    catch (e) {
        devkit_1.logger.error(e);
        throw new Error((0, devkit_1.stripIndents) `Error trying to find build configuration. ${options.buildTarget
            ? 'Try using an app of the same framework for the --build-target.'
            : 'Try manually specifying the build target with the --build-target flag.'}
    Provided project? ${options.project}
    Provided build target? ${options.buildTarget}
    Provided Executors? ${[...options.validExecutorNames].join(', ')}`);
    }
}
function findInTarget(tree, graph, options) {
    const { project, target, configuration } = (0, devkit_1.parseTargetString)(options.buildTarget, graph);
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, project);
    const executorName = projectConfig?.targets?.[target]?.executor;
    if (!options.validExecutorNames.has(executorName)) {
        devkit_1.logger.error((0, devkit_1.stripIndents) `NX The provided build target, ${options.buildTarget}, uses the '${executorName}' executor.
But only the follow executors are allowed
${Array.from(options.validExecutorNames)
            .map((ve) => ` - ${ve}`)
            .join('\n')}

${frameworkHelperMessage(Array.from(options.buildTarget), executorName)}
This is most likely because the provided --build-target is not a build target for an application or framework.
For example, the provide build target, '${options.buildTarget}' is:
 - the build target for a buildable/publishable library instead of an app.
 - using a different framework than expected like react library using an angular or next app build target.

If you do not have an app in the workspace to you can make a new app with 'nx g app' and use it just for component testing
`);
        throw new Error('The provided --build-target does not use an executor in the allow list of executors defined.');
    }
    const foundConfig = configuration || projectConfig?.targets?.[target]?.defaultConfiguration;
    return (0, devkit_1.readTargetOptions)({ project, target, configuration: foundConfig }, createExecutorContext(graph, projectConfig.targets, project, target, foundConfig));
}
function frameworkHelperMessage(validExecutorNames, executorName) {
    const executorsToFramework = {
        '@nx/webpack:webpack': 'react',
        '@nx/vite:build': 'react',
        '@nrwl/webpack:webpack': 'react',
        '@nrwl/vite:build': 'react',
        '@nx/angular:webpack-browser': 'angular',
        '@nrwl/angular:webpack-browser': 'angular',
        '@angular-devkit/build-angular:browser': 'angular',
        '@nx/next:build': 'next',
        '@nrwl/next:build': 'next',
    };
    const buildTargetFramework = executorsToFramework[executorName];
    const invokedGeneratorFramework = validExecutorNames.find((e) => !!executorsToFramework[e]);
    if (buildTargetFramework &&
        invokedGeneratorFramework &&
        buildTargetFramework !== invokedGeneratorFramework) {
        return `It looks like you're using a different plugin generator than the --build-target framework is set up for.
The provided build target is configured for ${buildTargetFramework} instead of ${invokedGeneratorFramework}.
Try using @nx/${buildTargetFramework} instead.`;
    }
    return '';
}
async function findInGraph(tree, graph, options) {
    const parents = findParentsOfProject(graph, options.project);
    const potentialTargets = [];
    for (const parent of parents) {
        const parentProject = findTargetOptionsInProject(tree, graph, parent.target, options);
        if (parentProject) {
            potentialTargets.push(parentProject);
        }
    }
    if (potentialTargets.length > 1) {
        devkit_1.logger.warn((0, devkit_1.stripIndents) `Multiple potential targets found for ${options.project}. Found ${potentialTargets.length}.
    Using ${potentialTargets[0].target}.
    To specify a different target use the --build-target flag.
    `);
    }
    return potentialTargets[0];
}
function findParentsOfProject(graph, projectName) {
    const reversedGraph = (0, devkit_1.reverse)(graph);
    return reversedGraph.dependencies[projectName]
        ? Object.values(reversedGraph.dependencies[projectName])
        : [];
}
function findTargetOptionsInProject(tree, graph, projectName, options) {
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    const includes = options.validExecutorNames;
    for (const targetName in projectConfig.targets) {
        const targetConfig = projectConfig.targets[targetName];
        if (includes.has(targetConfig.executor)) {
            return {
                target: `${projectName}:${targetName}`,
                config: !options.skipGetOptions
                    ? (0, devkit_1.readTargetOptions)({ project: projectName, target: targetName }, createExecutorContext(graph, projectConfig.targets, projectName, targetName, null))
                    : null,
            };
        }
    }
}
function createExecutorContext(graph, targets, projectName, targetName, configurationName) {
    const nxJsonConfiguration = (0, configuration_1.readNxJson)();
    const projectsConfigurations = (0, project_graph_1.readProjectsConfigurationFromProjectGraph)(graph);
    return {
        cwd: process.cwd(),
        projectGraph: graph,
        target: targets[targetName],
        targetName,
        configurationName,
        root: devkit_1.workspaceRoot,
        isVerbose: false,
        projectName,
        projectsConfigurations,
        nxJsonConfiguration,
    };
}
