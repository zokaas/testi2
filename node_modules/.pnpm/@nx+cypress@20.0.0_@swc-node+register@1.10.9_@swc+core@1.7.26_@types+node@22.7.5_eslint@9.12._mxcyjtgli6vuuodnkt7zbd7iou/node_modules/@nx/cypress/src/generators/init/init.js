"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addPlugin = addPlugin;
exports.cypressInitGenerator = cypressInitGenerator;
exports.cypressInitGeneratorInternal = cypressInitGeneratorInternal;
const devkit_1 = require("@nx/devkit");
const add_plugin_1 = require("@nx/devkit/src/utils/add-plugin");
const ts_solution_setup_1 = require("@nx/js/src/utils/typescript/ts-solution-setup");
const plugin_1 = require("../../plugins/plugin");
const versions_1 = require("../../utils/versions");
function setupE2ETargetDefaults(tree) {
    const nxJson = (0, devkit_1.readNxJson)(tree);
    if (!nxJson.namedInputs) {
        return;
    }
    // E2e targets depend on all their project's sources + production sources of dependencies
    nxJson.targetDefaults ??= {};
    const productionFileSet = !!nxJson.namedInputs?.production;
    nxJson.targetDefaults.e2e ??= {};
    nxJson.targetDefaults.e2e.cache ??= true;
    nxJson.targetDefaults.e2e.inputs ??= [
        'default',
        productionFileSet ? '^production' : '^default',
    ];
    (0, devkit_1.updateNxJson)(tree, nxJson);
}
function updateDependencies(tree, options) {
    const tasks = [];
    tasks.push((0, devkit_1.removeDependenciesFromPackageJson)(tree, ['@nx/cypress'], []));
    tasks.push((0, devkit_1.addDependenciesToPackageJson)(tree, {}, {
        ['@nx/cypress']: versions_1.nxVersion,
        cypress: versions_1.cypressVersion,
    }, undefined, options.keepExistingVersions));
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
function addPlugin(tree, graph, updatePackageScripts) {
    return (0, add_plugin_1.addPlugin)(tree, graph, '@nx/cypress/plugin', plugin_1.createNodesV2, {
        targetName: ['e2e', 'cypress:e2e', 'cypress-e2e'],
        openTargetName: ['open-cypress', 'cypress-open'],
        componentTestingTargetName: [
            'component-test',
            'cypress:component-test',
            'cypress-component-test',
        ],
        ciTargetName: ['e2e-ci', 'cypress:e2e-ci', 'cypress-e2e-ci'],
    }, updatePackageScripts);
}
function updateProductionFileset(tree) {
    const nxJson = (0, devkit_1.readNxJson)(tree);
    const productionFileset = nxJson.namedInputs?.production;
    if (productionFileset) {
        nxJson.namedInputs.production = Array.from(new Set([
            ...productionFileset,
            '!{projectRoot}/cypress/**/*',
            '!{projectRoot}/**/*.cy.[jt]s?(x)',
            '!{projectRoot}/cypress.config.[jt]s',
        ]));
    }
    (0, devkit_1.updateNxJson)(tree, nxJson);
}
async function cypressInitGenerator(tree, options) {
    return cypressInitGeneratorInternal(tree, { addPlugin: false, ...options });
}
async function cypressInitGeneratorInternal(tree, options) {
    (0, ts_solution_setup_1.assertNotUsingTsSolutionSetup)(tree, 'cypress', 'init');
    updateProductionFileset(tree);
    const nxJson = (0, devkit_1.readNxJson)(tree);
    options.addPlugin ??=
        process.env.NX_ADD_PLUGINS !== 'false' &&
            nxJson.useInferencePlugins !== false;
    if (options.addPlugin) {
        await addPlugin(tree, await (0, devkit_1.createProjectGraphAsync)(), options.updatePackageScripts);
    }
    else {
        setupE2ETargetDefaults(tree);
    }
    let installTask = () => { };
    if (!options.skipPackageJson) {
        installTask = updateDependencies(tree, options);
    }
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    return installTask;
}
exports.default = cypressInitGenerator;
